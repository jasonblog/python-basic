#類的細節

前面對類的有關內容已經描述不少了，其實話題遠遠沒有結束，不過對於初學者，掌握這些已經算是入門，在以後的實踐中，還需要進行體會和感悟。

這幾天和幾個朋友以各種途徑討論過OOP的相關問題，他們是：令狐蟲、Frank、晉劍、小馮

大家對OOP有不同看法，所謂工程派和學院派看法不一致。從應用的角度看，工程派的觀點是值得推薦的，那就是：不用太在意內部是怎麼工作的，只要能夠解決眼下的問題即可。但是，對於學習者而言，如果僅僅停留在工程派的層面（特別提醒，上述幾位朋友都是工程派的大俠，他們可不是簡單地能夠使用，其實是更高層次的“無招勝有招”），學習者可能感覺有點不透徹。所以，學習者，特別是初學者，要知道一些內部原因，但是也別爲了鑽研內部原因而忘記了應用的目的。看來兩者協調還是一個難辦的事情。不用着急，隨着實踐的深入，就逐漸有體會了。

下面我根據MARK Lutz的《Learning Python》中的“大師眼中的OOP”，列一些使用OOP的常見原因。

- 代碼重用。這是很簡單（並且是使用OOP的最主要原因）。通過支持繼承，類允許通過定製來編程，而不是每次都從頭開始一個項目。
- 封裝。在對象接口後包裝其實現的細節，從而隔離了代碼的修改對用戶產生的影響。
- 結構。類提供了一個新的本地作用域，最小化了變量名衝突。他們還提供了一種編寫和查找實現代碼，以及去管理對象狀態的自然場所。
- 維護性。類自然而然地促進了代碼的分解，這讓我們減少了冗餘。對虧支持類的結構以及代碼重用，這樣每次只需要修改代碼中一個拷貝就可以了。
- 一致性。類和繼承可以實現通用的接口。這樣代碼不僅有了統一的外表和觀感，還簡化了代碼的調試、理解以及維護。
- 多態。多態讓代碼更靈活和有了廣泛的適用性。（這似乎是OOP的屬性，不是使用它的理由）

不管怎麼樣，類是一個非常重要的東西，看官在學習的時候，一定要多加運用。

此外，對於python2來說，還有一個叫做“新式類”(new-style)的東西，這個對應於前面講過的類，那麼前面講過的類就稱爲“經典”(classic)類。但是，對於Python3來講，沒有這種區別，二者融合。只是在Python2中，兩個是有區別的。本教程在基礎部分，依然不講授新式類的問題，如果看官有興趣，可以自己在GOOGLE中查找有關資料，也可以隨着本課程深入，到下一個階段來學習。

##綁定和無綁定方法

看官是否還記得，在學習類的方法的時候，提到過，類的方法就是函數，只不過這個函數的表現有點跟前面學過的函數不一樣，比如有個self。當然，也不是必須要有的，下面看官就會看到沒有self的。既然方法和函數一樣，本質上都是函數，那麼，函數那部分學習的時候已經明確了：函數是對象，所以，類方法也是對象。正如剛纔說的，類的方法中，有的可以有self，有的可以沒有。爲了進行區別，進一步做了這樣的定義：

- 無綁定類方法對象：無self
- 綁定實例方法對象：有self

###調用綁定實例方法對象

    >>> class MyClass:
    ...     def foo(self,text):
    ...         print text
    ...

可以用下面的方式調用實例方法

    >>> a = MyClass()       #創建類實例
    >>> a.foo('qiwsir.github.io')       #調用實例方法
    qiwsir.github.io
    >>> a.foo
    <bound method MyClass.foo of <__main__.MyClass instance at 0xb74495ac>>

在這個實例方法調用的時候，其數據傳遞流程，在[《編寫類之二方法》](./218.md)中有一張圖，圖中顯示了，上述的調用方法中，其實已經將實例名稱a傳給了self，這就是調用綁定實例方法對象，有self。

上面的調用過程，還可以這樣來實現：

    >>> a = MyClass()
    >>> x = a.foo       #把實例a和方法函數foo綁定在一起
    >>> x
    <bound method MyClass.foo of <__main__.MyClass instance at 0xb74495ac>>
    >>> x("qiwsir.github.io")
    qiwsir.github.io

在上面的調用中，其實相當於前面的調用過程的分解動作。即先將實例a和方法函數foo綁定在一起，然後賦值給x，這時候x就相當於一個簡單函數一樣，可以通過上述方式傳入參數。這裏將實例和方法函數綁定的方式就是運用點號運算（object.method_function）

###調用無綁定類方法對象

所謂類方法對象，就是不通過實例，而是用類進行點號運算來獲得方法函數（ClassName.method_function）

    >>> a = MyClass()
    >>> y = MyClass.foo     #這裏沒有用類調用
    >>> y
    <unbound method MyClass.foo>

這樣的調用，就得到了無綁定方法對象，但是，調用的時候必須傳入實例做爲第一參數，如下

    >>> y(a,"qiwsir.github.io")
    qiwsir.github.io

否則，就報錯。請看官特別注意報錯信息

    >>> y("qiwsir.github.io")
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unbound method foo() must be called with MyClass instance as first argument (got str instance instead)
    >>>

在編程實踐中，似乎用實例方法調用更多一下。

##文檔字符串

在寫程序的時候，必須要寫必要的文字說明，沒別的原因，除非你的代碼寫的非常容易理解，特別是各種變量、函數和類等的命名任何人都能夠很容易理解，否則，文字說明是不可缺少的。

在函數、類或者文件開頭的部分寫文檔字符串說明，一般採用三重引號。這樣寫的最大好處是能夠用help()函數看。

    """This is python lesson"""

    def start_func(arg):
        """This is a function."""
        pass

    class MyClass:
        """Thi is my class."""
        def my_method(self,arg):
            """This is my method."""
            pass

這樣的文檔是必須的。

當然，在編程中，有不少地方要用“#”符號來做註釋。一般用這個來註釋局部。

類其實並沒有結束，不過本講座到此對類暫告一段。看官要多實踐。
