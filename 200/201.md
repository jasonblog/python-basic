#正規地說一句話

小孩子剛剛開始學說話的時候，常常是一個字一個字地開始學，比如學說“餃子”，對他/她來講，似乎有點難度，大人也聰明，於是就簡化了，用“餃餃”來代替，其實就是讓孩子學會一個字就能表達。當然，從教育學的角度，有人不贊成這種方法。這個此處不討論了。如果對比學習編程，就好像是前面已經學習過的那些各種類型的數據（對應這自然語言中的單個字、詞），要表達一個完整的意思，或者讓計算機完成一個事情（動作），不得不通過一句話，這句話就是語句，它是按照一定規則組織起來的。自然語言中的一句話，按照主謂賓的語法方式組織，計算機編程中的語句，也是按照一定的語法要求進行組織。

雖然在第一部分中，已經零星涉及到語句問題，並且在不同場合也進行了一些應用。畢竟不那麼系統。本部分，就比較系統地介紹python中的語句。

爲了有總括的印象，先看看python中都包括哪些語句：

- 賦值語句
- if語句，當條件成立時運行語句塊。經常與else, elif（相當於else if）配合使用。
- for語句，遍列列表、字符串、字典、集合等迭代器，依次處理迭代器中的每個元素。
- while語句，當條件爲真時，循環運行語句塊。
- try語句。與except, finally, else配合使用處理在程序運行中出現的異常情況。
- class語句。用於定義類型。
- def語句。用於定義函數和類型的方法。
- pass語句。表示此行爲空，不運行任何操作。
- assert語句。用於程序調適階段時測試運行條件是否滿足。
- with語句。Python2.6以後定義的語法，在一個場景中運行語句塊。比如，運行語句塊前加鎖，然後在語句塊運行退出後釋放鎖。
- yield語句。在迭代器函數內使用，用於返回一個元素。
- raise語句。拋出一個異常。
- import語句。導入一個模塊或包。常用寫法：from module import name, import module as name, from module import name as anothername

特別說明，以上劃分也不是很嚴格，有的內容，有的朋友不認爲屬於語句。這沒關係，反正就是那個東西，在編程中使用。不糾結於名詞歸類上。總之這些都是要掌握的，才能順利編程呢。

##再談賦值語句

還記得[賦值，簡單也不簡單](./127.md)那一講中所提到的賦值語句嗎？既然談語句，就應該從這個開始，一方面複習，另外一方面，希望能夠深點，深點的感覺總是很好的（我說的是理解python，思無邪。前面有一個關於list的內容：[再深點，更懂list](./119.md)，就有喜歡看玩笑的看官思邪了。哈哈。）

    >>> qiwsir = 1
    >>> python = 2
    >>> x, y = qiwsir, python   #相當於x=qiwsir,y=python
    >>> x
    1
    >>> y
    2
    >>> x, y                    #輸出的是tuple
    (1, 2)
    >>> [x, y]                  #這就是一個list
    [1, 2]

    >>> [a, b] = [qiwsir, python]
    >>> a
    1
    >>> b
    2
    >>> a, b
    (1, 2)
    >>> [a, b]
    [1, 2]

換一種方式，以上兩種賦值方法交叉組合一下：

    >>> [c, d] = qiwsir, python
    >>> c
    1
    >>> d
    2
    >>> c, d
    (1, 2)
    >>> f, g = [qiwsir, python]
    >>> f
    1
    >>> g
    2
    >>> f, g
    (1, 2)

居然也行。其實，從這裏我們就看出來了，賦值，就是對應着將左邊的變量和右邊的對象關聯起來。

有這樣一個有趣的問題，如果a=3,b=4，想把這兩個變量的值調換一下，也就是a=4，b=3。在有的高級語言中，是要先引入另外一個變量c做爲中間中專，就是這樣：

    a = 3
    b = 4
    c = a   #即c=3
    a = b   #a=4
    b = c   #b=3

初學者可能有點糊塗。就是我和你兩隻手都託着一個箱子，現在我們兩個要換一下箱子，但是兩個手都被佔用了，無法換（當然，要求箱子不能落地，也不要放在桌子上之類的）。於是再找一個名曰張三的人來，他空着兩隻手，那麼我先把箱子給張三，我就空出來了，然後接你的箱子，你的箱子就到我手裏了。我的那個箱子現在張三手裏呢，你接過來，於是我們兩個就換了箱子了。

只所以這麼囉嗦，就是因爲我們兩個沒有更多的手。但是，這不是python，python有更多的手。她可以這樣：

    >>> qiwsir = 100
    >>> python = 200
    >>> qiwsir, python = python, qiwsir
    >>> qiwsir
    200
    >>> python
    100

有點神奇，python是三頭六臂的。

##序列賦值

其實上面實驗的賦值，本質上就是序列賦值。只不過這裏再強化一番罷了。如果左邊的變量是序列，右邊的對象也是序列，兩者將一一對應地進行賦值。

    >>> [a, b, c] = (1, 2, 3)   #左右序列一一對應，左邊是變量，右邊是對象
    >>> a
    1
    >>> b
    2
    >>> c
    3
    >>> (a,b,c) = [1,2,3]
    >>> a
    1
    >>> b
    2
    >>> c
    3
    >>> [a,b,c] = "qiw"     #不要忘記了，str也是序列類型的數據
    >>> a
    'q'
    >>> b
    'i'
    >>> c
    'w'
    >>> (a,b,c) = "qiw"
    >>> a,c
    ('q', 'w')
    >>> a,b,c = 'qiw'       #與前面等價
    >>> a,b
    ('q', 'i')
    >>> a,b = 'qiw'         #報錯了，因爲左邊和右邊不是一一對應
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ValueError: too many values to unpack

    >>> (a,b),c = "qi","wei"    #注意觀察，這樣的像是是如何對應的
    >>> a,b,c
    ('q', 'i', 'wei')
    >>> string = "qiwsir"
    >>> a,b,c = string[0],string[1],string[2]   #取切片也一樣
    >>> a,b,c
    ('q', 'i', 'w')
    >>> (a,b),c = string[:2],string[2:]
    >>> a,b,c
    ('q', 'i', 'wsir')

從實驗中，可以看出，要搞清楚這種眼花繚亂的賦值，就僅僅扣住“一一對應”這個命脈即可。

如果看官用python3，在賦值上還有更多有意思的東西呢。不過，本講座用的還是python2。

