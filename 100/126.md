#深入變量和引用對象

今天是2014年8月4日，這段時間災禍接連發生，顯示不久前崑山的工廠爆炸，死傷不少，然後是雲南地震，也有死傷。爲所有在災難中受傷害的人們獻上禱告。

在[《永遠強大的函數》](./106.md)那一講中，老齊我（http://qiwsir.github.io）已經向看官們簡述了一下變量，之後我們就一直在使用變量，每次使用變量，都要有一個操作，就是賦值。本講再次提及這個兩個事情，就是要讓看官對變量和賦值有一個知其然和知其所以然的認識。當然，最後能不能達到此目的，主要看我是不是說的通俗易懂了。如果您沒有明白，就說明我說的還不夠好，可以聯繫我，我再爲您效勞。

##變量和對象

在[《learning python》](http://shop.oreilly.com/product/0636920028154.do)那本書裏面，作者對變量、對象和引用的關係闡述的非常明瞭。我這裏在很大程度上是受他的啓發。感謝作者Mark Lutz先生的鉅著。

應用《learning python》中的一個觀點：**變量無類型，對象有類型**

在python中，如果要使用一個變量，不需要提前聲明，只需要在用的時候，給這個變量賦值即可。這裏特彆強調，只要用一個變量，就要給這個變量賦值。

所以，像這樣是不行的。

    >>> x
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'x' is not defined

反覆提醒：一定要注意看報錯信息。如果光光地寫一個變量，而沒有賦值，那麼python認爲這個變量沒有定義。賦值，不僅僅是給一個非空的值，也可以給一個空值，如下，都是允許的

    >>> x = 3
    >>> lst = []
    >>> word = ""
    >>> my_dict = {}

在前面講述中，我提出了一個類比，就是變量通過一根線，連着對象（具體就可能是一個int/list等），這個類比被很多人接受了，算是我老齊的首創呀。那麼，如果要用一種嚴格的語言來描述，變量可以理解爲一個系統表的元素，它擁有過指向對象的命名空間。太嚴肅了，不好理解，就理解我那個類比吧。變量就是存在系統中的一個東西，這個東西有一種能力，能夠用一根線與某對象連接，它能夠釣魚。

對象呢？展開想象。在機器的內存中，系統分配一個空間，這裏面就放着所謂的對象，有時候放數字，有時候放字符串。如果放數字，就是int類型，如果放字符串，就是str類型。

接下來的事情，就是前面說的變量用自己所擁有的能力，把對象和自己連接起來（指針連接對象空間），這就是引用。引用完成，就實現了賦值。

![](../Pictures/12601.png)

看到上面的圖了吧，從圖中就比較鮮明的表示了變量和對象的關係。所以，嚴格地將，只有放在內存空間中的對象（也就是數據）纔有類型，而變量是沒有類型的。這麼說如果還沒有徹底明白，就再打一個比喻：變量就好比釣魚的人，湖水裏就好像內存，裏面有好多魚，有各種各樣的魚，它們就是對象。釣魚的人（變量）的任務就是用某種方式（魚兒引誘）把自己和魚通過魚線連接起來。那麼，魚是有類型的，有鰱魚、鯽魚、帶魚（帶魚也跑到湖水了了，難道是淡水帶魚？呵呵，就這麼扯淡吧，別較真），釣魚的人（變量）沒有這種類型，他釣到不同類型的魚。

這個比喻太爛了。湊合着理解吧。看官有好的比喻，別忘記分享。

同一個變量可以同時指向兩個對象嗎？絕對不能腳踩兩隻船。如果這樣呢？

    >>> x = 4
    >>> x = 5
    >>> x
    5

變量x先指向了對象4，然後指向對象5，當後者放生的時候，自動跟第一個對象4接觸關係。再看x，引用的對象就是5了。那麼4呢？一旦沒有變量引用它了，它就變成了孤魂野鬼。python是很吝嗇的，它絕對不允許在內存中存在孤魂野鬼。凡是這些東西都被看做垃圾，而對垃圾，python有一個自動的收回機制。

在網上找了一個圖示說明，很好，引用過來（來源：http://www.linuxidc.com/Linux/2012-09/69523.htm）

    >>> a = 100         #完成了變量a對內存空間中的對象100的引用

如下圖所示：

![](../Pictures/12602.png)

然後，又操作了：

    >>> a = "hello"

如下圖所示：

![](../Pictures/12603.png)

原來內存中的那個100就做爲垃圾被收集了。而且，這個收集過程是python自動完成的，不用我們操心。

那麼，python是怎麼進行垃圾收集的呢？在[Quora](http://www.quora.com)上也有人問這個問題，我看那個回答很精彩，做個鏈接，有性趣的讀一讀吧。[Python (programming language): How does garbage collection in Python work?](http://www.quora.com/Python-programming-language-1/How-does-garbage-collection-in-Python-work)

##is和==的效果

以上過程的原理搞清楚了，下面就可以深入一步了。

    >>> l1 = [1,2,3]
    >>> l2 = l1

這個操作中，l1和l2兩個變量，引用的是一個對象，都是[1,2,3]。何以見得？如果通過l1來修改[1,2,3]，l2引用對象也修改了，那麼就證實這個觀點了。

    >>> l1[0] = 99      #把對象變爲[99,2,3]
    >>> l1              #變了
    [99, 2, 3]
    >>> l2　            #真的變了吔
    [99, 2, 3]

再換一個方式：

    >>> l1 = [1,2,3]
    >>> l2 = [1,2,3]
    >>> l1[0] = 99
    >>> l1
    [99, 2, 3]
    >>> l2
    [1, 2, 3]

l1和l2貌似指向了同樣的一個對象[1,2,3]，其實，在內存中，這是兩塊東西，互不相關。只是在內容上一樣。就好像是水里長的一樣的兩條魚，兩個人都釣到了，當不是同一條。所以，當通過l1修改引用對象的後，l2沒有變化。

進一步還能這麼檢驗：

    >>> l1
    [1, 2, 3]
    >>> l2
    [1, 2, 3]
    >>> l1 == l2    #兩個相等，是指內容一樣
    True
    >>> l1 is l2    #is 是比較兩個引用對象在內存中的地址是不是一樣
    False　         #前面的檢驗已經說明，這是兩個東東

    >>> l3 = l1　　 #順便看看如果這樣，l3和l1應用同一個對象
    >>> l3
    [1, 2, 3]
    >>> l3 == l1
    True
    >>> l3 is l1    #is的結果是True
    True

某些對象，有copy函數，通過這個函數得到的對象，是一個新的還是引用到同一個對象呢？看官也可以做一下類似上面的實驗，就曉得了。比如：

    >>> l1
    [1, 2, 3]
    >>> l2 = l1[:]
    >>> l2
    [1, 2, 3]
    >>> l1[0] = 22
    >>> l1
    [22, 2, 3]
    >>> l2
    [1, 2, 3]

    >>> adict = {"name":"qiwsir","web":"qiwsir.github.io"}
    >>> bdict = adict.copy()
    >>> bdict
    {'web': 'qiwsir.github.io', 'name': 'qiwsir'}
    >>> adict["email"] = "qiwsir@gmail.com"
    >>> adict
    {'web': 'qiwsir.github.io', 'name': 'qiwsir', 'email': 'qiwsir@gmail.com'}
    >>> bdict
    {'web': 'qiwsir.github.io', 'name': 'qiwsir'}

不過，看官還有小心有點，python不總按照前面說的方式出牌，比如小數字的時候

    >>> x = 2
    >>> y = 2
    >>> x is y
    True
    >>> x = 200000
    >>> y = 200000
    >>> x is y      #什麼道理呀，小數字的時候，就用緩存中的.
    False

    >>> x = 'hello'
    >>> y = 'hello'
    >>> x is y
    True
    >>> x = "what is you name?"
    >>> y = "what is you name?"
    >>> x is y      #不光小的數字，短的字符串也是
    False

賦值是不是簡單地就是等號呢？從上面得出來，=的作用就是讓變量指針指向某個對象。不過，還可以再深入一些。走着瞧吧。
